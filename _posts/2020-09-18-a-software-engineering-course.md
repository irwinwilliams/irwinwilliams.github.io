---
title: "A Software Engineering Course"
date: "2020-09-18"
---

![](https://irwinium.files.wordpress.com/2020/09/image.png?w=1020)

A good conversation started because of that post on [Caribbean Developers](https://www.facebook.com/groups/devcarib/permalink/3013709558856058/). (Also, my Facebook is in Pirate, don't hate, lol).

When I saw this question, my first response was similar to quite a few others on the thread. "Teach a combination of these things: _CI/CD; Source Control; DevOps; Observability and Telemetry; UX_...".

But I didn't post it, because I had an inkling that something more was needed. That a three-month course to even masters-level students might not be sufficient to hit the mark. Then this hit me:

Which **true** Engineering discipline takes three months to understand?

I mean, Mendez' question asked about a Software Engineering course. I get where he's coming from. I did my undergrad at the University of the West Indies. And there was a Software Engineering course back then. It had a textbook and everything. That's where I learnt about Waterfall, XP and UML. Things I barely used over the last 15 years. I have drawn a lot of boxes on whiteboards, though.

I think back then it was thought that to a bunch of "programmers" (really, it was a _computer science_ programme), all that matters is knowing that software is "engineered" via "a process".

But. If that university wants to play a role in shaping future software engineers, I think a course of that duration isn't enough. Just like with other engineering disciplines, there's a certain base of understanding a student might need before the concerns of modern software engineering is discussed, but then the diet of consideration needs to be relevant and balanced.

At Teleios, our software engineering involves using Scrum, Kanban, various forms of test automation, front-end, back-end and distributed system development. We are continuing to deepen our investment in DevOps, telemetry & observability and have CI/CD as firm goals. We have dedicated design teams who communicate in a variety of ways customer intents. We believe in continuously developing skill as engineers by training and experimentation. We use design patterns and we've made up our own.

All that to say, if your software engineering program doesn't contemplate issues like that and above, what are you doing?

To go back to the original question, enough time should be given to properly understand the difference between git rebase and git merge. And why git's so popular even. Students of software engineering should be given a sight of the whole and what part code plays in it all (hint: not everything). In terms of a software development process, whichever one is selected, you don't really learn by simply reading the relevant manifesto. You really learn by doing.

You do Scrum. Or Kanban. Or whatever process. And it takes time for that doing to get meaningful. So, I think Mendez should return to the drawing board with fresh eyes on the goal and perhaps come up with a more valuable way to help his students understand the world of software engineering.

Going a bit further, when I first conceptualized this response, it took two paths. Either offer 2-4 different courses focused on elements of software engineering, so the whole MSc has a Software Engineering sub-focus, or, they embed SE concerns throughout the programme. With a deliberate goal of having students graduate with understanding what is involved in modern software engineering because almost every course had a component or a focus on some capability needed to effectively participate in software engineering.
